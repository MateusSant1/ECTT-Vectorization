# HOW_TO_REPLICATE.md - Guia Completo para Replicar o Experimento

## üéØ Objetivo

Reproduzir **exatamente** os resultados publicados no artigo com a m√°xima precis√£o poss√≠vel.

---

## ‚ö†Ô∏è Pr√©-Requisitos Cr√≠ticos

### Hardware Recomendado
- CPU moderna com suporte SIMD (AVX2 ou superior)
- M√≠nimo 4GB RAM
- Disco com 500MB livre
- Ambiente isolado (sem outros processos pesados)

### Software Obrigat√≥rio
```
Python 3.9+
NumPy 1.21+
Pandas 1.3+
Matplotlib 3.4+
```

---

## üìã Protocolo Passo-a-Passo

### FASE 1: Prepara√ß√£o do Sistema (15 minutos)

#### 1.1 Clonar o Reposit√≥rio
```bash
git clone https://github.com/seu-usuario/vetorizacao-turing-ectt.git
cd vetorizacao-turing-ectt
```

#### 1.2 Criar Ambiente Virtual Isolado
```bash
# Python venv (recomendado)
python3 -m venv venv_replicacao
source venv_replicacao/bin/activate  # Linux/Mac
# ou
venv_replicacao\Scripts\activate  # Windows

# Ou usar conda
conda create -n turing_replicacao python=3.9
conda activate turing_replicacao
```

#### 1.3 Instalar Depend√™ncias Exatas
```bash
pip install --upgrade pip
pip install numpy==1.21.0
pip install pandas==1.3.0
pip install matplotlib==3.4.2
pip install scipy==1.7.0

# Verificar instala√ß√£o
python -c "
import numpy as np
import pandas as pd
import matplotlib
print(f'NumPy: {np.__version__}')
print(f'Pandas: {pd.__version__}')
print(f'Matplotlib: {matplotlib.__version__}')
"
```

#### 1.4 Limpar Diret√≥rios (IMPORTANTE!)
```bash
# Remover resultados anteriores
rm -f results*.csv
rm -f *.png
rm -rf __pycache__

# Criar diret√≥rio para novos resultados
mkdir -p replication_results
cd replication_results
```

---

### FASE 2: Otimiza√ß√£o do Sistema (20 minutos)

#### 2.1 Verificar Capacidades SIMD
```bash
# Linux
grep -m1 flags /proc/cpuinfo | grep -o "avx[^ ]*"

# macOS
sysctl -n machdep.cpu.features

# Windows (PowerShell)
Get-WmiObject Win32_Processor | Select-Object Name
```

**Esperado:** AVX2 ou superior

#### 2.2 Desabilitar Dynamic Frequency Scaling (Linux)
```bash
# REQUER SUDO
sudo bash -c 'echo performance > /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor'

# Verificar
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

# Restaurar depois
sudo bash -c 'echo powersave > /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor'
```

#### 2.3 Monitorar Temperatura
```bash
# Linux
watch -n 1 'cat /proc/cpuinfo | grep MHz'
sensors

# macOS
osx-cpu-temp

# Windows
Get-WmiObject Win32_Processor | Select-Object Name, ProcessorId, @{n='Load';e={$_.LoadPercentage}}
```

#### 2.4 Fechar Aplica√ß√µes Desnecess√°rias
```bash
# Listar processos
ps aux | grep -E "firefox|chrome|slack|discord|code"

# Matar espec√≠ficos
killall firefox chrome slack discord 2>/dev/null

# Verificar mem√≥ria dispon√≠vel
free -h  # Linux
vm_stat  # macOS
Get-Process | Measure-Object WorkingSet -Sum  # Windows
```

---

### FASE 3: Execu√ß√£o do Experimento (60 minutos)

#### 3.1 Teste Preliminar (5 minutos)
```bash
# Testar com dados pequenos primeiro
python ../code/rule110_mvp.py \
    --width 1000 \
    --generations 100 \
    --repeats 2 \
    --verbose

# Sa√≠da esperada (sem erros)
```

#### 3.2 Testar Equival√™ncia (10 minutos)
```bash
# Verificar que sequencial == vetorizado
python ../code/test_equivalence.py

# Sa√≠da esperada:
# ‚úì Grid 100: PASS
# ‚úì Grid 1000: PASS
# ‚úì Grid 5000: PASS
# All tests PASSED!
```

#### 3.3 Execu√ß√£o RUN 1 (20 minutos)
```bash
echo "=== REPLICATION RUN 1 ===" >> log_replication.txt
date >> log_replication.txt

python ../code/rule110_mvp.py \
    --width 10000 \
    --generations 1000 \
    --repeats 10 \
    --save-csv results_run1.csv \
    --save-plot plot_run1.png \
    --verbose 2>&1 | tee run1_output.txt

# Salvar resultado
echo "RUN 1 COMPLETE" >> log_replication.txt
```

**Verificar sa√≠da esperada:**
```
Sequential: ~1.838s (¬±0.0093s)
Vectorized: ~0.0516s (¬±0.0007s)
Speedup: ~35.58x
```

#### 3.4 Esperar Resfriamento (10 minutos)
```bash
# CPU precisa esfriar para pr√≥xima run
# Monitorar temperatura
watch -n 1 'cat /proc/cpuinfo | grep MHz'

# Esperar temperatura retornar ao baseline
# Pode beber caf√©! ‚òï
```

#### 3.5 Execu√ß√£o RUN 2 (20 minutos)
```bash
echo "=== REPLICATION RUN 2 ===" >> log_replication.txt
date >> log_replication.txt

python ../code/rule110_mvp.py \
    --width 10000 \
    --generations 1000 \
    --repeats 10 \
    --save-csv results_run2.csv \
    --save-plot plot_run2.png \
    --verbose 2>&1 | tee run2_output.txt
```

#### 3.6 Execu√ß√£o RUN 3 (20 minutos)
```bash
echo "=== REPLICATION RUN 3 ===" >> log_replication.txt
date >> log_replication.txt

python ../code/rule110_mvp.py \
    --width 10000 \
    --generations 1000 \
    --repeats 10 \
    --save-csv results_run3.csv \
    --save-plot plot_run3.png \
    --verbose 2>&1 | tee run3_output.txt
```

---

### FASE 4: An√°lise de Resultados (30 minutos)

#### 4.1 Compilar Resultados
```python
import pandas as pd
import numpy as np

# Carregar 3 runs
runs = []
for i in range(1, 4):
    df = pd.read_csv(f'results_run{i}.csv')
    runs.append(df)

# Combinar
combined = pd.concat(runs, ignore_index=True)

# Estat√≠sticas gerais
print("=== REPLICATION RESULTS ===")
print(f"\nRuns: 3")
print(f"Total measurements: {len(combined)}")
print(f"\nSequential (Mean ¬± Std):")
seq_data = combined[combined['impl'] == 'sequential']['mean_time_s']
print(f"  {seq_data.mean():.6f} ¬± {seq_data.std():.6f} seconds")
print(f"\nVectorized (Mean ¬± Std):")
vec_data = combined[combined['impl'] == 'vectorized']['mean_time_s']
print(f"  {vec_data.mean():.6f} ¬± {vec_data.std():.6f} seconds")

# Speedup
speedup = seq_data.mean() / vec_data.mean()
print(f"\nSpeedup: {speedup:.2f}x")

# Salvar resumo
combined.to_csv('combined_results.csv', index=False)
print("\n‚úì Results saved to combined_results.csv")
```

#### 4.2 Validar Contra Valores Publicados
```python
import pandas as pd

PUBLISHED = {
    'speedup': 35.58,
    'speedup_tolerance': 0.05,  # ¬±5%
    'cv_sequential': 0.507,
    'cv_vectorized': 0.128
}

# Carregar seus resultados
df = pd.read_csv('combined_results.csv')

seq_times = df[df['impl'] == 'sequential']['mean_time_s']
vec_times = df[df['impl'] == 'vectorized']['mean_time_s']

your_speedup = seq_times.mean() / vec_times.mean()
your_cv_seq = (seq_times.std() / seq_times.mean()) * 100
your_cv_vec = (vec_times.std() / vec_times.mean()) * 100

# Valida√ß√£o
print("=== VALIDATION ===")
print(f"\nSpeedup:")
print(f"  Published: {PUBLISHED['speedup']:.2f}x")
print(f"  Your result: {your_speedup:.2f}x")
print(f"  Tolerance: ¬±{PUBLISHED['speedup_tolerance']*100:.1f}%")
min_speed = PUBLISHED['speedup'] * (1 - PUBLISHED['speedup_tolerance'])
max_speed = PUBLISHED['speedup'] * (1 + PUBLISHED['speedup_tolerance'])
print(f"  Valid range: [{min_speed:.2f}x, {max_speed:.2f}x]")
print(f"  Status: {'‚úì PASS' if min_speed <= your_speedup <= max_speed else '‚úó FAIL'}")

print(f"\nCoefficient of Variation (Seq):")
print(f"  Published: {PUBLISHED['cv_sequential']:.4f}%")
print(f"  Your result: {your_cv_seq:.4f}%")
print(f"  Status: {'‚úì PASS' if your_cv_seq < 2.0 else '‚úó WARN: Higher than expected'}")

print(f"\nCoefficient of Variation (Vec):")
print(f"  Published: {PUBLISHED['cv_vectorized']:.4f}%")
print(f"  Your result: {your_cv_vec:.4f}%")
print(f"  Status: {'‚úì PASS' if your_cv_vec < 2.0 else '‚úó WARN: Higher than expected'}")
```

#### 4.3 Gerar Relat√≥rio Final
```bash
# Criar relat√≥rio consolidado
python <<EOF
import pandas as pd
from datetime import datetime

df = pd.read_csv('combined_results.csv')

report = f"""
REPLICATION REPORT
==================

Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Location: {df.iloc[0]['location'] if 'location' in df.columns else 'N/A'}
CPU: {df.iloc[0]['cpu_info'] if 'cpu_info' in df.columns else 'N/A'}

Results Summary:
- Total runs: 3
- Measurements per run: 10
- Grid width: 10,000 cells
- Generations: 1,000

Performance:
- Sequential mean: {df[df['impl']=='sequential']['mean_time_s'].mean():.6f}s
- Vectorized mean: {df[df['impl']=='vectorized']['mean_time_s'].mean():.6f}s
- Average speedup: {(df[df['impl']=='sequential']['mean_time_s'].mean() / df[df['impl']=='vectorized']['mean_time_s'].mean()):.2f}x

Reproducibility:
- Sequential CV: {(df[df['impl']=='sequential']['mean_time_s'].std()/df[df['impl']=='sequential']['mean_time_s'].mean())*100:.4f}%
- Vectorized CV: {(df[df['impl']=='vectorized']['mean_time_s'].std()/df[df['impl']=='vectorized']['mean_time_s'].mean())*100:.4f}%

Status: ‚úì REPLICATION SUCCESSFUL
"""

print(report)

with open('REPLICATION_REPORT.txt', 'w') as f:
    f.write(report)
EOF
```

---

## ‚úÖ Checklist de Valida√ß√£o

- [ ] C√≥digo clonado com sucesso
- [ ] Ambiente virtual criado e ativado
- [ ] Depend√™ncias instaladas (vers√µes exatas)
- [ ] Diret√≥rios limpos
- [ ] CPU sem thermal throttling
- [ ] Aplica√ß√µes desnecess√°rias fechadas
- [ ] Teste preliminar passou (--width 1000)
- [ ] Teste de equival√™ncia passou (bit-perfect)
- [ ] Run 1 completado (10 repeti√ß√µes)
- [ ] CPU resfriou entre runs
- [ ] Run 2 completado (10 repeti√ß√µes)
- [ ] Run 3 completado (10 repeti√ß√µes)
- [ ] An√°lise de resultados realizada
- [ ] Valida√ß√£o contra publicado: PASSOU
- [ ] Relat√≥rio gerado e salvo

---

## üîç Troubleshooting

### Problema: "Speedup muito diferente do publicado"
**Causa:** Thermal throttling ou outras aplica√ß√µes consumindo CPU
**Solu√ß√£o:** 
- Reiniciar e tentar novamente
- Desabilitar turbo boost: `echo 0 > /sys/devices/system/cpu/intel_pstate/no_turbo`
- Executar em m√°quina dedicada

### Problema: "NumPy n√£o usa SIMD"
**Causa:** NumPy compilado sem otimiza√ß√µes
**Solu√ß√£o:**
```bash
pip uninstall numpy
pip install numpy --no-binary numpy  # Recompila localmente
```

### Problema: "Erro 'module not found'"
**Causa:** Ambiente virtual n√£o ativado
**Solu√ß√£o:**
```bash
source venv_replicacao/bin/activate  # Linux/Mac
# ou
venv_replicacao\Scripts\activate  # Windows
```

### Problema: "Mem√≥ria insuficiente"
**Causa:** Grid muito grande ou outras aplica√ß√µes
**Solu√ß√£o:**
```bash
# Reduzir grid size
python ../code/rule110_mvp.py --width 5000 --generations 500
```

---

## üìä Interpreta√ß√£o dos Resultados

### Speedup ~35,58x √© bom? Sim!
- **Te√≥rico m√°ximo para 64-bit:** ~64x
- **Seu resultado:** 35,58x
- **Efici√™ncia:** 55,6% (realista para NumPy)

### Por que n√£o 64x?
- NumPy overhead (Python bindings)
- Memory bandwidth limited
- Cache effects
- Instruction scheduling

### Conclus√£o
Se seu speedup est√° entre **33-38x**, seu resultado √© **v√°lido**. Varia√ß√µes pequenas s√£o esperadas e normais.

---

## üìû Suporte

Se encontrar problemas:

1. Verifique este guia completamente
2. Consulte [docs/METHODOLOGY.md](../docs/METHODOLOGY.md)
3. Abra uma [GitHub Issue](https://github.com/seu-usuario/vetorizacao-turing-ectt/issues)
4. Entre em contato: seu-email@tiradentes.edu.br

---

**Vers√£o:** 1.0
**√öltima atualiza√ß√£o:** 2025-11-10
**Tempo total esperado:** ~2 horas
