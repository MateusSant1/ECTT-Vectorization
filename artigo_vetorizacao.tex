\documentclass[12pt,oneside,a4paper,brazil]{abntex2}

\usepackage{placeins}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{lipsum}
\usepackage{newunicodechar}
\newunicodechar{λ}{\lambda}
\usepackage{titling}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning,calc}

\usepackage[brazil]{babel}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage[alf]{abntex2cite}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{hyperref}

\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}
\renewcommand{\thesubsubsection}{\thesubsection.\arabic{subsubsection}}

\titulo{Vetorização em Máquinas de Turing: Uma Validação Empírica da Tese de Church-Turing Estendida}

\autor{
Andrey Oliveira Santos \and
Caio Henrique das Chagas Santos \and
Guilherme Eugênio Sacramento Barreto \and
Isabela Guedes de Morais \and
Lizandra Bispo do Nascimento \and
Lucas Machado Delgado \and
Mateus Henrique de Araújo Santos \and
Pedro Afonso Quintela
}

\data{2025}

\begin{document}

\maketitle

\noindent \textbf{Instituição:} Universidade Tiradentes, Sistemas de Informação \\

\noindent \textbf{Local:} Aracaju - Sergipe \\

\noindent\textbf{Código-fonte:} \url{https://github.com/seu-usuario/vetorizacao-turing-ectt}

\vspace{0.5cm}

\data{2025}


\begin{resumo}

Este artigo investiga se a vetorização SIMD (Single Instruction Multiple Data), um modelo prático de paralelismo em computadores modernos, mantém a equivalência computacional prevista pela Tese de Church-Turing Estendida (ECTT). Implementamos o autômato celular Rule 110---provado ser Turing-completo---em duas formas: sequencial (simulando uma máquina de Turing) e vetorizada (utilizando instruções NumPy SIMD). 

Os resultados demonstram que ambas as implementações produzem saídas idênticas bit-a-bit (equivalência computacional), enquanto a versão vetorizada alcança aceleração de 35,58x (desvio padrão ±0,66\%), um fator polinomial e não exponencial. Esta evidência empírica valida a ECTT em contexto de hardware paralelo moderno, confirmando que a paralelização respeita os limites teóricos da computação. O trabalho estabelece uma ponte entre ciência da computação teórica e prática de sistemas, demonstrando que arquiteturas paralelas contemporâneas operam dentro dos limites previstos pela ECTT.

\textbf{Palavras-chave}: Vetorização. Máquinas de Turing. Tese de Church-Turing. SIMD. Equivalência Computacional.

\end{resumo}

\section{INTRODUÇÃO}

A Tese de Church-Turing, formulada independentemente por Alonzo Church e Alan Turing em 1936, estabelece os fundamentos teóricos da computação moderna ao definir formalmente quais processos podem ser mecanicamente computados \cite{turing1936, church1936}. Essa tese não é um teorema matemático formal, mas uma proposição filosófica que estabelece a equivalência entre diferentes modelos de computação.

A Tese de Church-Turing Estendida (ECTT) vai além: propõe que não apenas todos os modelos razoáveis de computação são equivalentes em poder computacional, mas também que são \textbf{polinomialmente equivalentes} em eficiência. Isto é, qualquer computação em um modelo pode ser simulada em outro com no máximo uma sobrecarga polinomial (fator multiplicativo constante).

Contudo, a ECTT nunca foi empiricamente testada contra arquiteturas paralelas modernas, particularmente aquelas que utilizam vetorização SIMD. Com o surgimento de processadores com instruções vetorizadas (AVX-512, AVX2, SIMD), uma questão fundamental ressurge: \textbf{a vetorização viola a ECTT?} Ou, mais especificamente, \textbf{consegue-se alcançar acelerações exponenciais através de vetorização, ou estas permanecem polinomiais como previsto?}

Este trabalho responde essas questões através de um estudo empírico utilizando o autômato celular Rule 110 como caso de teste. Rule 110 é escolhido porque: (1) é provadamente Turing-completo, podendo simular qualquer máquina de Turing; (2) exibe paralelismo natural (cada célula pode ser computada independentemente); (3) é simples o suficiente para ser implementado com clareza em múltiplas formas.

\textbf{Contribuições principais:}
\begin{itemize}
\item Primeira validação empírica da ECTT contra vetorização SIMD moderna
\item Demonstração de equivalência computacional perfeita (saídas idênticas)
\item Quantificação de aceleração polinomial: 35,58x com NumPy/SIMD
\item Metodologia reproduzível para comparar modelos sequenciais e paralelos
\item Confirmação de que paralelismo prático respeita limites teóricos
\end{itemize}

\section{TRABALHOS RELACIONADOS}

A pesquisa sobre \textbf{computabilidade} e equivalência entre modelos de computação é extensa. Nesta seção, organizamos a revisão em três eixos: (1) equivalência de modelos de computação; (2) vetorização e paralelismo em computadores modernos; (3) complexidade computacional prática.

\subsection{Equivalência de Modelos de Computação}

A base teórica da equivalência computacional foi estabelecida por \citeonline{church1936} ao introduzir o $\lambda$-cálculo e por \citeonline{turing1936} com suas máquinas abstratas. Ambos chegaram à conclusão de que funções definíveis em seus respectivos formalismos representam exatamente as \textbf{funções efetivamente computáveis}.

\citeonline{kozen1997} consolida esses resultados, demonstrando rigorosamente que múltiplos modelos (máquinas de Turing, $\lambda$-cálculo, autômatos com pilha ilimitada, sistemas de reescrita) são \textbf{Turing-completos} e portanto têm poder de computação equivalente.

Trabalhos posteriores exploram essas equivalências em contextos específicos. \citeonline{barendregt1984} e \citeonline{selinger2004} analisam a questão pelo lado do cálculo lambda, enquanto \citeonline{frontiers2020} revisita a relevância contemporânea da Tese de Church-Turing no contexto de computação quântica e outros modelos emergentes.

\subsection{Autômatos Celulares e Turing-Completude}

Rule 110, o autômato celular unidimensional estudado neste trabalho, foi provado ser Turing-completo por Cook em 2002. Um resultado importante para nosso estudo é que Rule 110 exibe \textbf{paralelismo natural}: o estado de cada célula pode ser computado independentemente das outras, desde que se tenha acesso aos estados anteriores dos vizinhos.

A literatura sobre autômatos celulares (Wolfram, 2002) demonstra que essa estrutura paralela é inerente ao modelo, não um artefato de implementação. Isto torna os autômatos celulares ideais para estudar a relação entre paralelismo teórico e implementações práticas.

\subsection{Vetorização SIMD e Paralelismo}

Vetorização SIMD (Single Instruction Multiple Data) é estudada em múltiplos contextos:

\begin{itemize}
\item \textbf{Arquitetura de processadores:} Instruções como SSE (128-bit), AVX2 (256-bit), e AVX-512 (512-bit) permitem que uma única instrução CPU processe múltiplos elementos de dados. A biblioteca NumPy (utilizada neste trabalho) aproveita essas instruções automaticamente.

\item \textbf{Teoria de complexidade:} \citeonline{dallago2009} e \citeonline{tromp2006} estabelecem modelos de custo formais, relacionando operações de programação funcional com passos de máquinas de Turing. Esses modelos predizem que acelerações devem ser polinomiais.

\item \textbf{Prática da computação:} Estudos de otimização mostram que eficiência SIMD típica está na faixa de 40-80\% do teórico (Fog, 2023), devido a limitações de banda de memória, hierarquia de cache, e overhead de instruções.
\end{itemize}

\subsection{Complexidade Computacional}

A Tese de Church-Turing Estendida prediz que a aceleração entre modelos é no máximo polinomial. A teoria de complexidade computacional (P, NP, classes de redução) é construída inteiramente sobre essa premissa \cite{kozen1997}.

Se vetorização conseguisse acelerações exponenciais, teria implicações profundas: problemáticas intratáveis poderiam tornar-se tratáveis através de puro paralelismo, sem algoritmos melhores. Nossa evidência empírica (aceleração de ~35x, verificada como polinomial) sugere que isso não ocorre.

\section{METODOLOGIA}

Para investigar se vetorização SIMD mantém equivalência computacional com máquinas de Turing sequenciais, adotamos um método experimental comparativo com três etapas: (1) implementação de dois modelos (sequencial e vetorizado); (2) verificação de equivalência e coleta de métricas de desempenho; (3) análise estatística e interpretação.

\subsection{Modelos Implementados}

\subsubsection{Rule 110 Sequencial (Modelo Turing)}

Implementamos Rule 110 de forma sequencial, processando uma célula por vez a cada geração. A função de regra é definida como:

\begin{equation}
f_{\text{rule110}}(left, center, right) = \text{lookup\_table}[(left \ll 2) | (center \ll 1) | right]
\end{equation}

onde \texttt{lookup\_table} = [0,1,1,1,0,1,1,0] é a tabela de decisão de Rule 110.

Este modelo simula fielmente uma máquina de Turing processando a fita sequencialmente, com transições de estado determinísticas.

\subsubsection{Rule 110 Vetorizado (Modelo Paralelo SIMD)}

Implementamos uma versão vetorizada usando NumPy que computa múltiplas células simultaneamente:

\begin{equation}
\text{state}_{\text{new}} = (left \oplus center) \vee (left \oplus right) \wedge \neg(left \wedge center \wedge right)
\end{equation}

onde as operações ocorrem em paralelo sobre arrays. NumPy usa instruções SIMD da CPU (AVX2 ou superior) para executar essas operações em múltiplos elementos.

Ambas as implementações são \textbf{logicamente idênticas} (computam a mesma função boolean), mas diferem na estratégia de execução.

\subsection{Configuração Experimental}

\begin{itemize}
\item \textbf{Tamanho da grade:} 10.000 células (representando um estado da fita de uma máquina de Turing)
\item \textbf{Gerações:} 1.000 iterações (equivalente a 1.000 passos de uma máquina de Turing)
\item \textbf{Repetições:} 10 execuções de cada implementação
\item \textbf{Estado inicial:} Uma única célula ativa, resto inativo (padrão em Rule 110)
\item \textbf{Condições de contorno:} Periódicas (wraparound), essencial para equivalência formal
\item \textbf{Ferramenta de medição:} \texttt{time.perf\_counter()} (Python) com resolução de microsegundos
\end{itemize}

\subsection{Métricas Coletadas}

\begin{itemize}
\item \textbf{Tempo de execução:} Wall-clock time em segundos (média e desvio padrão)
\item \textbf{Estabilidade:} Coeficiente de Variação (CV = $\sigma / \mu \times 100\%$), alvo < 10\%
\item \textbf{Equivalência:} Comparação byte-por-byte de outputs (deve ser 100\% idêntico)
\item \textbf{Aceleração:} Speedup = $T_{\text{sequencial}} / T_{\text{vetorizado}}$
\item \textbf{Eficiência:} Efficiency = (Speedup / Largura Vetorial Teórica) × 100\%
\end{itemize}

\section{RESULTADOS}

\subsection{Verificação de Equivalência}

Ambas as implementações produzem outputs \textbf{bit-perfeitos idênticos} em todos os testes. Não foram detectadas discrepâncias byte-a-byte. Este resultado é fundamental: comprova que vetorização \textbf{não altera o que pode ser computado}, apenas como é computado.

\begin{table}[htbp]
\centering
\caption{Resultados de Benchmarking - Rule 110 (10.000 células, 1.000 gerações, 10 repetições)}
\label{tab:resultados}
\begin{tabular}{|l|r|r|r|}
\hline
\textbf{Implementação} & \textbf{Tempo Médio (s)} & \textbf{Desvio Padrão (s)} & \textbf{CV (\%)} \\
\hline
Sequencial & 1,8378 & 0,0093 & 0,507 \\
Vetorizada (NumPy) & 0,0516 & 0,0007 & 0,128 \\
\hline
\textbf{Aceleração} & \multicolumn{3}{c|}{35,58x} \\
\hline
\textbf{Eficiência} & \multicolumn{3}{c|}{55,6\% (relativo ao máximo teórico ~64x)} \\
\hline
\end{tabular}
\end{table}

\subsection{Análise de Desempenho}

\subsubsection{Aceleração Alcançada}

A versão vetorizada alcança \textbf{35,58x de aceleração}. Este resultado é notável:

\begin{itemize}
\item \textbf{Acima do esperado para MVP:} Esperávamos 10-15x; alcançamos 2,4-3,6x melhor
\item \textbf{Polynomial, não exponencial:} É um fator constante, independente do tamanho do problema
\item \textbf{Alinhado com ECTT:} Confirma a previsão de equivalência polinomial
\end{itemize}

\subsubsection{Estabilidade de Medições}

A notável estabilidade dos resultados reforça a confiabilidade:

\begin{itemize}
\item \textbf{Sequencial CV: 0,507\%} (muito abaixo do alvo < 10\%)
\item \textbf{Vetorizada CV: 0,128\%} (excepcional, <0,2\%)
\end{itemize}

Essa consistência sub-percentual indica que os resultados são altamente reproduzíveis e confiáveis para publicação.

\subsubsection{Eficiência Relativa}

Eficiência = $35,58 / 64 \times 100\% = 55,6\%$

Esta eficiência de 55,6\% é \textbf{realista e esperada} para SIMD prático:

\begin{itemize}
\item Largura teórica de 64-bit (8 inteiros de 8-bit) não é totalmente utilizável
\item Limitações de banda de memória (cada célula precisa dos vizinhos)
\item Overhead de instruções (address calculations, memory access patterns)
\item Overhead de Python/NumPy (não é C puro ou assembly otimizado)
\item Benchmarks industriais típicos: 40-70\% de eficiência para SIMD
\end{itemize}

\subsection{Validação da ECTT}

\subsubsection{Teste de Escala}

Para confirmar que a aceleração é \textbf{polinomial} e não \textbf{exponencial}, executamos testes preliminares variando o tamanho:

\begin{itemize}
\item Tamanho 10.000: Speedup ~35,58x
\item Tamanho 20.000: Speedup ~35,2x (praticamente idêntico)
\item Tamanho 5.000: Speedup ~36,1x (variação < 2\%)
\end{itemize}

A invariância da aceleração com tamanho do problema confirma que o speedup é um \textbf{fator constante}, exatamente como predito pela ECTT. Se fosse exponencial, veríamos mudanças drásticas com o tamanho.

\subsubsection{Interpretação Teórica}

O resultado 35,58x speedup valida a ECTT porque:

\begin{enumerate}
\item \textbf{Equivalência computacional:} Outputs idênticos $\Rightarrow$ funções idênticas
\item \textbf{Aceleração polinomial:} Fator 35,58x é constante $\Rightarrow$ polinomial, não exponencial
\item \textbf{Preservação de Turing-completude:} Rule 110 permanece Turing-completo $\Rightarrow$ nenhuma mudança em computabilidade
\end{enumerate}

Portanto: \textbf{Vetorização é um modelo razoável de computação que respeita a Tese de Church-Turing Estendida.}

\begin{figure}[htbp]
\centering
\includegraphics[width=0.7\textwidth]{speedup_result.png}
\caption{Comparação de desempenho: implementação sequencial (1,838s) vs. vetorizada (0,052s). O speedup de 35,58x é polinomial, confirmando a ECTT. As barras de erro mostram ±1 desvio padrão (n=10).}
\label{fig:speedup}
\end{figure}

\section{DISCUSSÃO}

\subsection{O que estes resultados provam sobre a ECTT}

Estes resultados fornecem \textbf{validação empírica} da Tese de Church-Turing Estendida em um contexto onde ainda não tinha sido testada: hardware paralelo SIMD moderno.

A ECTT prediz que paralelismo não deveria fornecer vantagem exponencial. Nossos resultados (35,58x aceleração polynomial) confirmam exatamente isso. Se vectorização violasse ECTT, seria possível resolver problemas intratáveis (ex: P=NP) através de puro paralelismo. Nossa evidência sugere que não.

\subsection{Implicações Teóricas}

Três conclusões teóricas seguem:

\begin{enumerate}
\item \textbf{Arquitetura não muda computabilidade:} Paralelismo é um efeito de hardware, não computacional. O conjunto de funções computáveis permanece idêntico.

\item \textbf{Complexidade permanece relevante:} Um algoritmo O($n^2$) vetorizado ainda é O($n^2$)---35,58x mais rápido, mas mesma classe de complexidade.

\item \textbf{ECTT permanece válida:} Mesmo com a sofisticação da arquitetura paralela moderna, os limites teóricos fundamentais se mantêm.
\end{enumerate}

\subsection{Limitações do Estudo}

Este trabalho possui limitações que devem ser reconhecidas:

\begin{enumerate}
\item \textbf{NumPy, não bare-metal SIMD:} NumPy usa SIMD internamente, mas há overhead de Python. Um programa C puro com intrínsecos AVX-512 poderia alcançar maior speedup (possivelmente até 55,6\%), mas ainda seria polinomial.

\item \textbf{Algoritmo específico:} Rule 110 é altamente paralelizável (cada célula independente). Algoritmos com dependências de dados complexas podem mostrar padrões diferentes. Contudo, a ECTT deveria sustentar-se.

\item \textbf{Hardware específico:} Este estudo usa processadores CPU com SIMD. GPUs, TPUs, ou outras aceleradores podem mostrar speedups diferentes, mas a previsão polinomial da ECTT deveria manter-se.

\item \textbf{Sem análise formal de complexidade:} Medimos empiricamente; uma prova formal de overhead polinomial seria mais rigorosa.
\end{enumerate}

\subsection{Comparação com Computação Quântica}

Um ponto de comparação interessante é a computação quântica. \citeonline{shor1994} apresenta algoritmos quânticos para fatoração que rodam em tempo polinomial, onde sequencialmente seria exponencial.

Porém, mesmo computadores quânticos não conseguem resolver problemas indecidíveis (como o Problema da Parada). Eles ampliam \textit{eficiência} dentro da ECTT, mas não violam seus limites.

\section{CONCLUSÕES}

Este trabalho fornece \textbf{primeira evidência empírica} de que vetorização SIMD, um modelo prático de paralelismo em hardware moderno, respeita a Tese de Church-Turing Estendida.

Os resultados-chave:

\begin{itemize}
\item \textbf{Equivalência computacional comprovada:} Saídas bit-perfeitas idênticas entre sequencial e vetorizado
\item \textbf{Aceleração polinomial quantificada:} 35,58x speedup (fator constante)
\item \textbf{ECTT validada empiricamente:} Paralelismo não fornece vantagem exponencial
\item \textbf{Reproduzibilidade excepcional:} Coeficiente de variação < 1%, permitindo publicação
\end{itemize}

Estes achados sugerem que a Tese de Church-Turing permanece um fundamento sólido da computação mesmo enquanto a arquitetura de hardware evolui. Paralelismo prático não as viola; opera dentro delas.

\subsection{Trabalhos Futuros}

Extensões naturais deste trabalho:

\begin{enumerate}
\item Testar outros autômatos celulares Turing-completos (ex: totalistic rules)
\item Comparar diferentes níveis de SIMD (SSE, AVX2, AVX-512, GPU CUDA)
\item Implementar versão bare-metal C com intrínsecos AVX-512 para máxima eficiência
\item Estender para modelos paralelos tradicionais (multithreading, MPI)
\item Formalizar análise de complexidade e prova de overhead polinomial
\item Investigar comportamento em algoritmos não-paralelizáveis (controle de fluxo complexo)
\end{enumerate}

\FloatBarrier

\bibliography{referencias_vetorizacao}

\end{document}